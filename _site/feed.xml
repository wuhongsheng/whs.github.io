<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WHS</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 12 Sep 2018 09:20:55 +0800</pubDate>
    <lastBuildDate>Wed, 12 Sep 2018 09:20:55 +0800</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Android 性能优化</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#什么是内存泄漏&quot; id=&quot;markdown-toc-什么是内存泄漏&quot;&gt;什么是内存泄漏&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#为什么内存泄漏不好&quot; id=&quot;markdown-toc-为什么内存泄漏不好&quot;&gt;为什么内存泄漏不好&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#如何识别&quot; id=&quot;markdown-toc-如何识别&quot;&gt;如何识别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#常见的内存泄漏的原因&quot; id=&quot;markdown-toc-常见的内存泄漏的原因&quot;&gt;常见的内存泄漏的原因&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#anr问题&quot; id=&quot;markdown-toc-anr问题&quot;&gt;ANR问题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#如何避免anr&quot; id=&quot;markdown-toc-如何避免anr&quot;&gt;如何避免ANR&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#性能优化指标&quot; id=&quot;markdown-toc-性能优化指标&quot;&gt;性能优化指标&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考&quot; id=&quot;markdown-toc-参考&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

每个应用程序都需要内存作为执行其工作的资源。为了确保Android中的每个应用程序都有足够的内存，Android系统需要有效地管理内存分配。当内存不足时，Android运行时会触发垃圾收集（GC）。GC的目的是通过清理不再有用的对象来回收内存。简而言之，为用户提供服务的所有内容都应保存在内存中，其他所有内容都将从内存中消失以释放资源。
但是，如果以不良方式编写代码，从可访问对象以某种方式引用未使用的对象，GC会将未使用的对象标记为有用对象，因此无法删除它们。这称为内存泄漏。

&lt;h3 id=&quot;什么是内存泄漏&quot;&gt;什么是内存泄漏&lt;/h3&gt;

每个应用程序都需要内存作为执行其工作的资源。为了确保Android中的每个应用程序都有足够的内存，Android系统需要有效地管理内存分配。当内存不足时，Android运行时会触发垃圾收集（GC）。GC的目的是通过清理不再有用的对象来回收内存。简而言之，为用户提供服务的所有内容都应保存在内存中，其他所有内容都将从内存中消失以释放资源。
但是，如果以不良方式编写代码，从可访问对象以某种方式引用未使用的对象，GC会将未使用的对象标记为有用对象，因此无法删除它们。这称为内存泄漏。

&amp;lt;div align=center&amp;gt;&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F1.png&quot; alt=&quot;&quot; /&gt;

Java中有四种GC根：
&lt;ul&gt;
  &lt;li&gt;
    &lt;strong&gt;局部变量&lt;/strong&gt;由一个线程堆栈保持活动状态。这不是真实对象虚拟参考，因此不可见。对于所有意图和目的，局部变量是GC根。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;活动Java线程&lt;/strong&gt;始终被视为活动对象，因此是GC根。这对于线程局部变量尤为重要。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;静态变量&lt;/strong&gt;由其类引用。这一事实使它们成为事实上的GC根源。类本身可以被垃圾收集，这将删除所有引用的静态变量。当我们一般使用应用程序服务器，OSGi容器或类加载器时，这一点特别重要。我们将在“问题模式”部分讨论相关问题。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;JNI引用&lt;/strong&gt;是本机代码作为JNI调用的一部分创建的Java对象。这样创建的对象是专门处理的，因为JVM不知道它是否被本机代码引用。这些对象代表了一种非常特殊的GC根形式，我们将在下面的“问题模式”部分中详细介绍。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么内存泄漏不好&quot;&gt;为什么内存泄漏不好&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;界面卡顿&lt;/li&gt;
&lt;/ul&gt;

&amp;lt;div align=center&amp;gt;&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Android%E7%BB%98%E5%88%B6%E7%AA%97%E5%8F%A3.png&quot; alt=&quot;&quot; /&gt;

&lt;div style=&quot;align: center&quot;&gt;
&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%94%B1%E4%BA%8E%E9%A2%91%E7%B9%81GC%E5%AF%BC%E8%87%B4%E4%B8%A2%E5%A4%B1%E5%B8%A7.png&quot; /&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    ANR

    &lt;ol&gt;
      &lt;li&gt;在5秒内无响应输入事件（如按键或屏幕触摸事件）&lt;/li&gt;
      &lt;li&gt;BroadcastReceiver尚未在10秒内完成执行。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    OOM-&amp;gt;崩溃
  &lt;/li&gt;
  &lt;li&gt;
    在QA/测试中很难找到内存泄漏问题。它们难以复制。崩溃报告通常很难推理，因为它可以在Android系统拒绝内存分配的任何时间发生。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何识别&quot;&gt;如何识别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LeakCanary工具&lt;/li&gt;
&lt;/ul&gt;

它会为您的应用中的活动创建弱引用。（您也可以通过向任何其他对象添加监视来自定义它。）然后检查GC之后是否清除了引用。如果没有，它会将堆转储到.hprof文件中并进行分析以确认是否存在泄漏。如果有，则显示通知，并在单独的应用程序中显示泄漏发生的参考树。

&lt;ul&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://developer.android.google.cn/studio/profile/am-hprof&quot;&gt;HPROF Viewer and Analyzer&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://developer.android.google.cn/studio/profile/memory-profiler&quot;&gt;Memory Profiler&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常见的内存泄漏的原因&quot;&gt;常见的内存泄漏的原因&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Leak activity to a static reference&lt;/li&gt;
  &lt;li&gt;Leak activity to a worker thread&lt;/li&gt;
  &lt;li&gt;Leak thread itself&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;anr问题&quot;&gt;ANR问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;导出 traces.txt 文件&lt;/li&gt;
&lt;/ul&gt;

通过adb导出 data/anr/traces.txt

&lt;h4 id=&quot;如何避免anr&quot;&gt;如何避免ANR&lt;/h4&gt;

不要在主线程(UI线程)里面做繁重的操作.

&lt;h3 id=&quot;性能优化指标&quot;&gt;性能优化指标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;启动时间&lt;/li&gt;
  &lt;li&gt;界面切换是否卡顿&lt;/li&gt;
  &lt;li&gt;过度绘制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;a href=&quot;https://android.jlelse.eu/memory-leak-patterns-in-android-4741a7fcb570&quot;&gt;Memory Leak Patterns in Android&lt;/a&gt;

&lt;a href=&quot;https://www.dynatrace.com/resources/ebooks/javabook/how-garbage-collection-works/&quot;&gt;Java Memory Management&lt;/a&gt;

</description>
        <pubDate>Wed, 15 Aug 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/08/15/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/15/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        
        <category>Android</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>使用TensorFlow对花朵进行简单分类</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#主要步骤&quot; id=&quot;markdown-toc-主要步骤&quot;&gt;主要步骤&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#下一步&quot; id=&quot;markdown-toc-下一步&quot;&gt;下一步&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#常见问题及解决方法&quot; id=&quot;markdown-toc-常见问题及解决方法&quot;&gt;常见问题及解决方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考&quot; id=&quot;markdown-toc-参考&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

我们将使用转移学习，这意味着我们从一个已经接受另一个问题培训的模型开始。然后我们将重新训练类似的问题。从头开始深入学习可能需要几天时间，但可以在短时间内完成转移学习。

我们将使用在ImageNet大型视觉识别挑战数据集上训练的模型。这些模型可以区分达尔马提亚或洗碗机等1,000个不同的类别。您将可以选择模型架构，因此您可以确定问题的速度，大小和准确性之间的正确折中。

我们将使用这个相同的模型，但重新训练它可以根据我们自己的例子区分少数类。

&lt;h3 id=&quot;主要步骤&quot;&gt;主要步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;a href=&quot;http://wuhongsheng.top/2017/12/15/TensorFlow%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/&quot;&gt;安装TensorFlow&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    克隆git存储库
  &lt;/li&gt;
&lt;/ul&gt;

此代码中使用的所有代码都包含在此git存储库中。克隆存储库并cd放入其中。这是我们将要工作的地方。

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/googlecodelabs/tensorflow-for-poets-2

cd tensorflow-for-poets-2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下载训练图像&lt;/li&gt;
&lt;/ul&gt;

在开始任何培训之前，您需要一组图像来教授模型有关您想要识别的新课程。我们创建了创作共用许可花卉照片的档案，以供初次使用。通过调用以下两个命令下载照片（218 MB）：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://download.tensorflow.org/example_images/flower_photos.tgz \
    | tar xz -C tf_files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

你现在应该有一个花卉照片的副本。通过发出以下命令来确认工作目录的内容：
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls tf_files / flower_photos

daisy/
dandelion/
roses/
sunflowers/
tulip/
LICENSE.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;再训练网络&lt;/li&gt;
&lt;/ul&gt;

&lt;strong&gt;配置你的MobileNet&lt;/strong&gt;

在这个练习中，我们将重新培训一个MobileNet。MobileNet是一个小型高效卷积神经网络。“卷积”意味着在图像中的每个位置执行相同的计算。

MobileNet可以通过两种方式进行配置：

输入图像分辨率：128,160,192或224px。毫不奇怪，摄入更高分辨率的图像需要更多的处理时间，但会导致更好的分类准确性。
模型的相对大小作为最大的MobileNet的一小部分：1.0,0.75,0.50或0.25。
这个codelab我们将使用224 0.5。

使用推荐的设置，通常只需几分钟即可在笔记本电脑上进行再培训。您将在Linux shell变量中传递设置。在shell中设置这些变量：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IMAGE_SIZE=224
ARCHITECTURE=&quot;mobilenet_0.50_${IMAGE_SIZE}&quot;

# 查看变量
echo $IMAGE_SIZE
224

# 通过发出以下命令来激活该 conda 环境
source activate tensorflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;strong&gt;启动TensorBoard&lt;/strong&gt;

在开始训练之前，tensorboard在后台启动。TensorBoard是一种包含在tensorflow中的监测和检测工具。您将使用它来监控培训进度。
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tensorboard --logdir tf_files/training_summaries &amp;amp;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;strong&gt;查看再训练脚本&lt;/strong&gt;

重新训练脚本来自TensorFlow Hub回购，但不作为pip包的一部分进行安装。所以为了简单起见，我将它包含在codelab存储库中。您可以使用该python命令运行脚本。花一点时间浏览一下“帮助”。

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python -m scripts.retrain -h

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;strong&gt;运行训练脚本&lt;/strong&gt;

如引言中所述，ImageNet模型是具有数百万个参数的网络，可以区分大量的类。我们只训练该网络的最后一层，因此训练将在合理的时间内结束。

用一个大命令开始你的再训练（注意–summaries_dir选项，发送训练进度报告到tensorboard监测的目录）：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python -m scripts.retrain \
  --bottleneck_dir = tf_files / bottlenecks \
  --how_many_training_steps = 500 \
  --model_dir = tf_files / models / \
  --summaries_dir = tf_files / training_summaries /“$ {ARCHITECTURE}”\
  --output_graph = tf_files / retrained_graph.pb \
  --output_labels = tf_files / retrained_labels.txt \
  --architecture =“$ {ARCHITECTURE}”\
  --image_dir = tf_files / flower_photos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

请注意，此步骤需要一段时间。

该脚本下载预先训练好的模型，添加一个新的最终图层，并在您下载的花卉照片上训练该图层。

ImageNet不包括我们在这里培训的任何这些花卉物种。但是，使ImageNet可以区分1,000个类别的信息种类对区分其他对象也很有用。通过使用这个预先训练的网络，我们将这些信息用作最终分类层的输入，以区分我们的花类。

&lt;ul&gt;
  &lt;li&gt;使用再训练模型&lt;/li&gt;
&lt;/ul&gt;

再训练脚本将数据写入以下两个文件：

tf_files/retrained_graph.pb，其中包含所选网络的一个版本，并在您的类别上重新培训最后一层。
tf_files/retrained_labels.txt，这是一个包含标签的文本文件。

&lt;strong&gt;分类图像&lt;/strong&gt;

codelab repo还包含tensorflow的label_image.py示例的副本，您可以使用它来测试您的网络。花一点时间阅读此脚本的帮助：
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python -m scripts.label_image -h

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
现在，让我们在雏菊的这个图像上运行脚本：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python -m scripts.label_image \
    --graph=tf_files/retrained_graph.pb  \
    --image=tf_files/flower_photos/daisy/21652746_cc379e0eea_m.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
每次执行都会打印出花标的列表，在大多数情况下，正确的花在顶部（尽管每个重新训练的模型可能略有不同）。

你可能会得到这样的雏菊照片的结果：
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;daisy (score = 0.99071)
sunflowers (score = 0.00595)
dandelion (score = 0.00252)
roses (score = 0.00049)
tulips (score = 0.00032)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;可选训练参数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--learning_rate 
#参数控制训练期间最后一层更新的大小(比如0.005，训练需要更长的时间，但总体精度可能会增加。值越高learning_rate，比如1.0，可以训练速度更快，但通常会降低精度，甚至使培训不稳定。)

--summaries_dir 
#是控制张量板中名称的选项。之前我们使用过：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;根据自己数据进行训练&lt;/li&gt;
&lt;/ul&gt;

看到脚本处理花图像后，您可以开始观察网络教学以识别不同的类别。

从理论上讲，你需要做的就是运行该工具，指定一组特定的子文件夹。每个子文件夹都按照您的某个类别命名，并仅包含该类别的图像。

如果您完成此步骤并传递子目录的根文件夹作为参数的–image_dir参数，那么脚本应该训练您提供的图像，就像它为花一样。

分类脚本使用文件夹名称作为标签名称，每个文件夹内的图像应该是与该标签对应的图片，如花卉档案中所示：

&lt;img src=&quot;https://codelabs.tensorflowers.cn/codelabs/tensorflow-for-poets/img/9444bbae4d5d9ab1.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;下一步&quot;&gt;下一步&lt;/h3&gt;

恭喜，您迈出了深入学习的更大的世界！

您可以在&lt;a href=&quot;https://tensorflow.google.cn/&quot;&gt;TensorFlow网站&lt;/a&gt;或TensorFlow GitHub &lt;a href=&quot;https://github.com/tensorflow/&quot;&gt;项目&lt;/a&gt;中查看有关使用TensorFlow的更多信息。TensorFlow还有许多其他资源，包括&lt;a href=&quot;https://groups.google.com/a/tensorflow.org/forum/#!forum/discuss&quot;&gt;讨论组&lt;/a&gt;和&lt;a href=&quot;https://www.tfimgs.cn/resources/pdfs/45166.pdf&quot;&gt;白皮书&lt;/a&gt;。

如果您有兴趣在移动设备上运行TensorFlow，请尝试本教程的第二部分：有三个版本：

&lt;a href=&quot;https://codelabs.tensorflowers.cn/codelabs/tensorflow-for-poets-2-tflite/index.html#&quot;&gt;TFLite Android&lt;/a&gt;
&lt;a href=&quot;https://codelabs.tensorflowers.cn/codelabs/tensorflow-for-poets-2-ios/index.html#0&quot;&gt;TFLite iOS&lt;/a&gt;
&lt;a href=&quot;https://codelabs.tensorflowers.cn/codelabs/tensorflow-for-poets-2/index.html#0&quot;&gt;TFMobile Android&lt;/a&gt;

或者去&lt;a href=&quot;http://playground.tensorflow.org/#activation=tanh&amp;amp;batchSize=10&amp;amp;dataset=circle&amp;amp;regDataset=reg-plane&amp;amp;learningRate=0.03&amp;amp;regularizationRate=0&amp;amp;noise=0&amp;amp;networkShape=4,2&amp;amp;seed=0.74359&amp;amp;showTestData=false&amp;amp;discretize=false&amp;amp;percTrainData=50&amp;amp;x=true&amp;amp;y=true&amp;amp;xTimesY=false&amp;amp;xSquared=false&amp;amp;ySquared=false&amp;amp;cosX=false&amp;amp;sinX=false&amp;amp;cosY=false&amp;amp;sinY=false&amp;amp;collectStats=false&amp;amp;problem=classification&amp;amp;initZero=false&amp;amp;hideText=false&quot;&gt;TensorFlow游乐场&lt;/a&gt;玩一下吧！

&lt;h3 id=&quot;常见问题及解决方法&quot;&gt;常见问题及解决方法&lt;/h3&gt;

&lt;strong&gt;问题&lt;/strong&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;InvalidArgumentError (see above for traceback): Expected image (JPEG, PNG, or GIF), got unknown format starting with '\000\005\026\007\000\002\000\000Mac OS X'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;strong&gt;解决方法&lt;/strong&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://codelabs.tensorflowers.cn/codelabs/tensorflow-for-poets/index.html#0&quot;&gt;TensorFlow Codelabs&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://tensorflow.google.cn/tutorials/image_retraining&quot;&gt;retraining tutorial&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://petewarden.com/2016/02/28/tensorflow-for-poets/&quot;&gt;Pete Warden’s TensorFlow for Poets blog&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 12 Jun 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/06/12/%E4%BD%BF%E7%94%A8TensorFlow%E5%AF%B9%E8%8A%B1%E6%9C%B5%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%88%86%E7%B1%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/12/%E4%BD%BF%E7%94%A8TensorFlow%E5%AF%B9%E8%8A%B1%E6%9C%B5%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%88%86%E7%B1%BB/</guid>
        
        <category>AI</category>
        
        <category>TensorFlow</category>
        
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>产品原型设计</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#google教程&quot; id=&quot;markdown-toc-google教程&quot;&gt;Google教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;google教程&quot;&gt;Google教程&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;amp;mid=2652046181&amp;amp;idx=1&amp;amp;sn=50ac9cf4c8b645a64f73335d13094f77&amp;amp;chksm=808ca320b7fb2a36d2013d8722cdad38dba9abea8486ca6c4d841777c7e3b7a729f9e2df45c6&amp;amp;scene=21#wechat_redirect&quot;&gt;上篇&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;amp;mid=2652046404&amp;amp;idx=1&amp;amp;sn=40757c4cb8abe5ecad83d789923ba87a&amp;amp;chksm=808ca401b7fb2d17a8ddc3c51c83a1b5cbe2c0f57eaef24e6e8db75cae54b13b3d9d51b26fbe&amp;amp;scene=21#wechat_redirect&quot;&gt;中篇&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;https://mp.weixin.qq.com/s/Zht9agRrayFRgU39XJ6H3g&quot;&gt;下篇&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 01 Jun 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/06/01/%E4%BA%A7%E5%93%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/01/%E4%BA%A7%E5%93%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/</guid>
        
        <category>原型设计</category>
        
        <category>产品</category>
        
        
        <category>产品</category>
        
      </item>
    
      <item>
        <title>ArcGISRuntime For Android开发</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#常见问题&quot; id=&quot;markdown-toc-常见问题&quot;&gt;常见问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

ArcGISRuntime For Android 开发

&lt;h5 id=&quot;常见问题&quot;&gt;常见问题&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;编辑空间数据&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;问题描述&lt;/li&gt;
&lt;/ul&gt;

添加空间数据时出现一下问题

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java.util.concurrent.ExecutionException: com.esri.arcgisruntime.ArcGISRuntimeException: The data types are not compatible.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;问题原因及解决方法&lt;/li&gt;
&lt;/ul&gt;

可能是新增空间数据字段类型和地图服务图层字段类型不匹配

</description>
        <pubDate>Tue, 15 May 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/05/15/ArcGISRuntime-For-Android%E5%BC%80%E5%8F%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/15/ArcGISRuntime-For-Android%E5%BC%80%E5%8F%91/</guid>
        
        <category>GIS</category>
        
        
        <category>GIS</category>
        
      </item>
    
      <item>
        <title>常用SVN命令及问题</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#svn简介&quot; id=&quot;markdown-toc-svn简介&quot;&gt;SVN简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#常用命令&quot; id=&quot;markdown-toc-常用命令&quot;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。

&lt;h3 id=&quot;svn简介&quot;&gt;SVN简介&lt;/h3&gt;

&lt;h3 id=&quot;常用命令&quot;&gt;常用命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 项目checkout 到本地 checkout 可以替换为co  https://svn.url/project为服务器地址 ./mpath为本地存储路径
svn checkout https://svn.url/project --username xxxx --password xxx ./mpath   

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

第一次运行会出现下面的问题 就是询问接受方式，一般写p，以后就不会再出现了！
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error validating server certificate for 'https://172.17.1.8:443':  
 - The certificate is not issued by a trusted authority. Use the  
   fingerprint to validate the certificate manually!  
 - The certificate hostname does not match.  
Certificate information:  
 - Hostname: BJ-AD-FS.hyc-tec.net  
 - Valid: from Fri, 03 May 2013 01:18:50 GMT until Mon, 01 May 2023 01:18:50 GMT  
 - Issuer: BJ-AD-FS.hyc-tec.net  
 - Fingerprint: 16:c5:8a:cf:f5:25:9d:df:54:79:0f:0d:42:03:70:29:04:9b:c2:a8  
(R)eject, accept (t)emporarily or accept (p)ermanently?   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 20 Apr 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/04/20/%E5%B8%B8%E7%94%A8SVN%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/04/20/%E5%B8%B8%E7%94%A8SVN%E5%91%BD%E4%BB%A4/</guid>
        
        <category>SVN</category>
        
        
        <category>代码版本控制</category>
        
      </item>
    
      <item>
        <title>Android APK打包技巧</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#apk拆分&quot; id=&quot;markdown-toc-apk拆分&quot;&gt;APK拆分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

APK拆分常用方法

&lt;h4 id=&quot;apk拆分&quot;&gt;APK拆分&lt;/h4&gt;

通过 APK 拆分，您可以高效地基于屏幕密度或 ABI 创建多个 APK。 例如，您可以利用 APK 拆分创建单独的 hdpi 和 mdpi 版本应用，同时仍将它们视为一个变体，并允许其共享测试应用、javac、dx 和 ProGuard 设置。

如需了解有关使用 APK 拆分的详细信息，请参阅 &lt;a href=&quot;http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits&quot;&gt;APK 拆分&lt;/a&gt;.

</description>
        <pubDate>Wed, 07 Mar 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/03/07/Android-APK%E6%89%93%E5%8C%85/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/07/Android-APK%E6%89%93%E5%8C%85/</guid>
        
        <category>AS</category>
        
        <category>Gradle</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>AndroidStudio手动下载配置Gradle</title>
        <description>
相信使用AS的童鞋都会遇到这个问题，每次更新项目Gradle版本的时候，AS下载非常缓慢，有时候点停止下载还会造成AS卡死。对于这个问题大致有以下三种解决方法

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://services.gradle.org/distributions/&quot;&gt;Gradle下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    使用VPN下载

    我就是通过这种方式下载的，需要注意的是，要先开VPN然后再打开AS下载。
  &lt;/li&gt;
  &lt;li&gt;
    手动下载配置

    &lt;a href=&quot;https://blog.csdn.net/fuchaosz/article/details/51567808&quot;&gt;参考文章&lt;/a&gt;

    既然有大神写了，而且比较详细，我就不再班门弄斧了。
  &lt;/li&gt;
  &lt;li&gt;
    使用国内镜像地址

    使用阿里云的国内镜像仓库地址，就可以快速的下载需要的文件修改项目根目录下的文件 build.gradle ：
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;buildscript {
    repositories {
        maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}
    }
}

allprojects {
    repositories {
        maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

然后重新构建项目就可以了

</description>
        <pubDate>Wed, 07 Mar 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/03/07/AndroidStudio%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AEGradle/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/07/AndroidStudio%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AEGradle/</guid>
        
        <category>AS</category>
        
        <category>Gradle</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>ArcServer发布可同步地图服务</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#操作流程以103arcserver为例&quot; id=&quot;markdown-toc-操作流程以103arcserver为例&quot;&gt;操作流程（以10.3ArcServer为例）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考链接&quot; id=&quot;markdown-toc-参考链接&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

从ArcGIS 10.2.1开始推出离在线一体化技术之后，数据的离在线一体化编辑一直是大家所关注的一个热点。数据存储在企业级地理数据库中，通过ArcGIS桌面软件加载后配图处理，并发布到ArcGIS for Server中，供移动端设备离线编辑使用，并可以同步回传版本化存档。这其中涉及多项配置操作，本篇文章主要针对FeatureService服务的发布流程做一个简单的介绍。以备查阅。
 &lt;img src=&quot;https://images2015.cnblogs.com/blog/412448/201609/412448-20160909164428254-500287581.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;操作流程以103arcserver为例&quot;&gt;操作流程（以10.3ArcServer为例）&lt;/h3&gt;

1.准备数据源（ArcSDE）-&amp;gt;2.添加GlobalId-&amp;gt;3.启用存档-&amp;gt;4.制作地图文档(MXD)-&amp;gt;5.新增数据库连接-&amp;gt;6.添加Server连接-&amp;gt;7.注册数据库到服务器-&amp;gt;8.发布服务

&lt;ol&gt;
  &lt;li&gt;在CataLog中连接数据库、新建数据集、新建图层&lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E8%BF%9E%E6%8E%A5SDE.png&quot; alt=&quot;连接SDE&quot; /&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E6%96%B0%E5%BB%BA%E8%A6%81%E7%B4%A0%E9%9B%86.png&quot; alt=&quot;新建数据集&quot; /&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E6%96%B0%E5%BB%BA%E8%A6%81%E7%B4%A0%E7%B1%BB.png&quot; alt=&quot;新建要素类&quot; /&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5.png&quot; alt=&quot;添加字段&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;添加GlobalId&lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E6%B7%BB%E5%8A%A0Globalid.png&quot; alt=&quot;添加GlobalId&quot; /&gt;

在增加GlobalId时可能会出现与数据锁冲突，如下图所示：执行SQL解除锁
   &lt;code class=&quot;highlighter-rouge&quot;&gt;select * from sde.table_locks for update
  &lt;/code&gt;

&lt;ol&gt;
  &lt;li&gt;启用存档，这不用没问题&lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E5%90%AF%E7%94%A8%E5%AD%98%E6%A1%A3.png&quot; alt=&quot;启用存档&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    保存mxd文件
  &lt;/li&gt;
  &lt;li&gt;
    新建数据库连接
  &lt;/li&gt;
  &lt;li&gt;
    添加Server连接
  &lt;/li&gt;
  &lt;li&gt;
    注册数据库到服务器
  &lt;/li&gt;
  &lt;li&gt;
    发布地图服务
  &lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E5%8F%91%E5%B8%83%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1.png&quot; alt=&quot;发布地图服务&quot; /&gt;

&lt;img src=&quot;http://ooxw95lkz.bkt.clouddn.com/%E5%BC%80%E5%90%AF%E5%90%8C%E6%AD%A5%E5%8A%9F%E8%83%BD.jpg&quot; alt=&quot;开启同步功能&quot; /&gt;

&lt;h3 id=&quot;参考链接&quot;&gt;参考链接&lt;/h3&gt;

&lt;a href=&quot;https://server.arcgis.com/zh-cn/server/latest/get-started/windows/tutorial-set-up-feature-service-data-for-offline-use.htm&quot;&gt;https://server.arcgis.com/zh-cn/server/latest/get-started/windows/tutorial-set-up-feature-service-data-for-offline-use.htm&lt;/a&gt;

&lt;a href=&quot;https://server.arcgis.com/zh-cn/server/latest/get-started/windows/tutorial-create-offline-maps-with-versioned-data.htm&quot;&gt;https://server.arcgis.com/zh-cn/server/latest/get-started/windows/tutorial-create-offline-maps-with-versioned-data.htm&lt;/a&gt;

&lt;a href=&quot;http://www.cnblogs.com/gis-luq/p/5857188.html&quot;&gt;http://www.cnblogs.com/gis-luq/p/5857188.html&lt;/a&gt;

</description>
        <pubDate>Wed, 07 Mar 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/03/07/ArcServer%E5%8F%91%E5%B8%83%E5%8F%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/07/ArcServer%E5%8F%91%E5%B8%83%E5%8F%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9C%B0%E5%9B%BE%E6%9C%8D%E5%8A%A1/</guid>
        
        <category>GIS</category>
        
        <category>ArcServer</category>
        
        
        <category>GIS</category>
        
      </item>
    
      <item>
        <title>Android启动加速优化</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#背景资料&quot; id=&quot;markdown-toc-背景资料&quot;&gt;背景资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#常见问题及优化方式&quot; id=&quot;markdown-toc-常见问题及优化方式&quot;&gt;常见问题及优化方式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#启动主题切换&quot; id=&quot;markdown-toc-启动主题切换&quot;&gt;启动主题切换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#avoid-heavy-app-initialization&quot; id=&quot;markdown-toc-avoid-heavy-app-initialization&quot;&gt;Avoid Heavy App Initialization&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#heavy-activity-initialization&quot; id=&quot;markdown-toc-heavy-activity-initialization&quot;&gt;Heavy activity initialization&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#diagnosing-the-problem&quot; id=&quot;markdown-toc-diagnosing-the-problem&quot;&gt;Diagnosing The Problem&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考文章&quot; id=&quot;markdown-toc-参考文章&quot;&gt;参考文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

随着项目版本的迭代，App的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关，从本篇文章开始，我将开启一个Android应用性能优化的专题，从理论到实战，从入门到深挖，手把手将性能优化实践到项目中，欢迎持续关注！

&lt;h2 id=&quot;背景资料&quot;&gt;背景资料&lt;/h2&gt;

&lt;blockquote&gt;
  应用的启动分为冷启动、热启动、温启动，而启动最慢、挑战最大的就是冷启动：系统和App本身都有更多的工作要从头开始！
应用在冷启动之前，要执行三个任务：
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;加载启动App；&lt;/li&gt;
  &lt;li&gt;App启动之后立即展示出一个空白的Window；&lt;/li&gt;
  &lt;li&gt;创建App的进程；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  而这三个任务执行完毕之后会马上执行以下任务：
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;建App对象；&lt;/li&gt;
  &lt;li&gt;启动Main Thread；&lt;/li&gt;
  &lt;li&gt;创建启动的Activity对象；&lt;/li&gt;
  &lt;li&gt;加载View；&lt;/li&gt;
  &lt;li&gt;布置屏幕；&lt;/li&gt;
  &lt;li&gt;进行第一次绘制；&lt;/li&gt;
&lt;/ol&gt;

而一旦App进程完成了第一次绘制，系统进程就会用Main Activity替换已经展示的Background Window，此时用户就可以使用App了。

&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4056837-36c808285a70cf1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; /&gt;

同样，Google也给出了启动加速的方向：

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；&lt;/li&gt;
    &lt;li&gt;避免在启动时做密集沉重的初始化（Heavy app initialization）；&lt;/li&gt;
    &lt;li&gt;定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

可以通过以下命令测试启动耗时

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb shell am start -W com.titan.asfh/com.titan.asfh.login.LoginActivity
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;常见问题及优化方式&quot;&gt;常见问题及优化方式&lt;/h2&gt;

&lt;h3 id=&quot;启动主题切换&quot;&gt;启动主题切换&lt;/h3&gt;

按照官方文档的说明：使用Activity的windowBackground主题属性来为启动的Activity提供一个简单的drawable。
Layout XML file:

&lt;pre class=&quot;prettyprint lang-xml&quot;&gt;
	  &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
         &amp;lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&amp;gt;
           &lt;!-- The background color, preferably the same as your normal theme --&gt;
           &amp;lt;item android:drawable=&quot;@android:color/white&quot;/&amp;gt;
           &lt;!-- Your product logo - 144dp color version of your app icon --&gt;
           &amp;lt;item&amp;gt;
             &amp;lt;bitmap
               android:src=&quot;@mipmap/logo&quot;
               android:gravity=&quot;center&quot;/&amp;gt;
             &amp;lt;/item&amp;gt;
        &amp;lt;/layer-list&amp;gt;
&lt;/pre&gt;

Style:

&lt;pre class=&quot;prettyprint lang-xml&quot;&gt;

 &amp;lt;style name=&quot;AppTheme.launcher&quot; parent=&quot;AppTheme.NoTitle&quot;&amp;gt;
         &amp;lt;item name=&quot;android:windowBackground&quot;&amp;gt;@drawable/launcher &amp;lt;/item&amp;gt;
  &amp;lt;/style&amp;gt;
 
&lt;/pre&gt;

Manifest file:

&lt;pre class=&quot;prettyprint lang-xml&quot;&gt;

&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;

&amp;lt;activity android:name=&quot;.login.LoginActivity&quot;
            android:screenOrientation=&quot;portrait&quot;
            android:theme=&quot;@style/AppTheme.launcher&quot;
            &amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;
                &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
 &amp;lt;/activity&amp;gt;
 
&lt;/pre&gt;

Activity:

&lt;pre class=&quot;prettyprint lang-java&quot;&gt;

public class LoginActivity extends BaseActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setTheme(R.style.AppTheme_NoTitle);
        super.onCreate(savedInstanceState);
       
    }
}
 
&lt;/pre&gt;

实际测试发现，启动确实避免启动白屏的问题，但是无论时冷启动还是热启动都会有背景图，实测QQ、微信不是这样，判断
它们是通过增加Splash Activity实现的。

此外这样也可以解决白屏问题

&lt;pre class=&quot;prettyprint lang-xml&quot;&gt;
&amp;lt;style name=&quot;AppTheme.launcher&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&amp;gt;
&lt;/pre&gt;

&lt;h3 id=&quot;avoid-heavy-app-initialization&quot;&gt;Avoid Heavy App Initialization&lt;/h3&gt;

当代码覆盖Application 对象时，启动性能会受到影响，并在初始化该对象时执行繁重的工作或复杂的逻辑。如果您的应用程序子类执行不需要完成的初始化，您的应用程序可能会浪费时间在启动过程中。一些初始化可能是完全不必要的：例如，当应用程序实际启动以响应意图时，初始化主要活动的状态信息。意图是，应用程序只使用以前初始化的状态数据的一个子集。

应用程序初始化过程中的其他挑战包括垃圾收集事件的影响或数量众多，或磁盘I / O与初始化同时发生，进一步阻止初始化过程。垃圾收集尤其是Dalvik运行时的一个考虑因素; Art运行时同时执行垃圾收集，最大限度地减少操作的影响。

&lt;strong&gt;诊断问题&lt;/strong&gt;

您可以使用方法跟踪或内联跟踪来尝试诊断问题。

&lt;strong&gt;方法追踪&lt;/strong&gt;
运行方法跟踪器工具显示该 callApplicationOnCreate() 方法最终调用您的com.example.customApplication.onCreate 方法。如果该工具显示这些方法需要很长时间才能完成执行，那么您应该进一步研究以查看正在进行的工作。

&lt;strong&gt;内联追踪&lt;/strong&gt;
使用内联追踪来调查可能的罪魁祸首，包括：
你的应用程序的初始onCreate() 功能。
任何全球单身人士对象您的应用程序初始化。
任何磁盘I / O，反序列化，或瓶颈期间可能发生的紧密循环。

&lt;strong&gt;解决问题的办法&lt;/strong&gt;
无论问题出在不必要的初始化还是磁盘I / O，解决方案都会调用延迟初始化对象：只初始化那些立即需要的对象。例如，不是创建全局静态对象，而是移动到单例模式，应用程序只在第一次访问对象时创建对象。另外，考虑使用像&lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; 这样的依赖注入框架来创建对象，并且依赖关系是当它们被首次注入时。

&lt;h3 id=&quot;heavy-activity-initialization&quot;&gt;Heavy activity initialization&lt;/h3&gt;

活动创建通常需要大量的高开销工作。通常，有机会优化这项工作来实现性能改进。这些常见问题包括：

膨胀大型或复杂的布局。
阻塞磁盘或网络I / O的屏幕绘图。
加载和解码位图。
栅格化VectorDrawable对象。
初始化活动的其他子系统。
诊断问题
在这种情况下，方法跟踪和内联跟踪也是有用的。

&lt;strong&gt;方法追踪&lt;/strong&gt;
当运行Method Tracer工具时，特定的区域将关注于您的应用程序的Application子类构造函数和 com.example.customApplication.onCreate()方法。

如果该工具显示这些方法需要很长时间才能完成执行，那么您应该进一步研究以查看正在进行的工作。

&lt;strong&gt;内联追踪&lt;/strong&gt;
使用内联追踪来调查可能的罪魁祸首，包括：

你的应用程序的初始onCreate() 功能。
它初始化的任何全局单例对象。
任何磁盘I / O，反序列化，或瓶颈期间可能发生的紧密循环。
&lt;strong&gt;解决问题的办法&lt;/strong&gt;
有很多潜在的瓶颈，但是两个常见的问题和解决办法如下：

视图层次越大，应用所需的时间就越多。你可以采取两个步骤来解决这个问题：
通过减少冗余或嵌套布局来平整您的视图层次结构。
不要在启动时不需要显示部分UI。相反，使用ViewStub对象作为应用程序可以在更适当的时间膨胀的子层次结构的占位符。
在主线程上完成所有的资源初始化操作也会减慢启动速度。你可以解决这个问题如下：
移动所有的资源初始化，以便应用程序可以在不同的线程上执行它。
允许应用程序加载并显示您的视图，然后更新依赖于位图和其他资源的视觉属性。

&lt;h3 id=&quot;diagnosing-the-problem&quot;&gt;Diagnosing The Problem&lt;/h3&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;

&lt;a href=&quot;https://developer.android.com/topic/performance/launch-time.html&quot;&gt;Launch-Time Performance&lt;/a&gt;

&lt;a href=&quot;https://www.jianshu.com/p/f5514b1a826c&quot;&gt;Android性能优化（一）之启动加速35%&lt;/a&gt;

</description>
        <pubDate>Wed, 24 Jan 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/01/24/Android%E5%90%AF%E5%8A%A8%E5%8A%A0%E9%80%9F%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/24/Android%E5%90%AF%E5%8A%A8%E5%8A%A0%E9%80%9F%E4%BC%98%E5%8C%96/</guid>
        
        <category>性能优化</category>
        
        <category>Android</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>华为手机刷机</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#解决思路&quot; id=&quot;markdown-toc-解决思路&quot;&gt;解决思路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

最近老妈的手机出现系统损坏的情况，开机时重复开机动画，进入不了系统界面。初步判断时老妈误操作删除系统文件，或者手机中毒。
本来不太想动手的，我就说这手机也用几年，该换了。老妈回了一句，还说你是做软件的，这个问题都解决不了，明天拿给修手机的看看。这句刺激我了，于是动手解决问题，花了两个小时左右。最后在这里记录一下解决问题的经过。

&lt;h3 id=&quot;解决思路&quot;&gt;解决思路&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;双清&lt;/li&gt;
&lt;/ul&gt;

百度一下，进入手机Recovery模式(同时按住电源键和音量’-‘3秒即可进入)，进行双清(清理系统缓存信息、清理用户数据)操作。
尝试后问题依然无法解决

&lt;ul&gt;
  &lt;li&gt;求助官方售后&lt;/li&gt;
&lt;/ul&gt;

打电话到华为售后，售后说可以通过华为的手机助手客户端修复，我尝试了也没有解决问题。客户端提示没有合适的系统包。可能是手机系统版本比较老了。

然后再次电话到售后，问能不能刷机，获知，华为手机要刷机需要先解锁，我们都知道华为的系统是基于Android系统改造的，厂商在底层系统加了锁，意味着没办法随意刷机。必须先解锁，解锁需要提供手机型号、IMEI、序列号、产品识别码。其中序列号和产品识别码在手机包装盒上有，或者在手机系统信息里查询。但我现在到哪去找N年前的手机包装盒啊，手机也打不开，所以这条路也走不通。

&lt;ul&gt;
  &lt;li&gt;刷机&lt;/li&gt;
&lt;/ul&gt;

手机方面的专业术语，是指通过一定的方法更改或替换手机中原本存在的一些语言、图片、铃声、软件或者操作系统。通俗来讲，刷机就是给手机重装系统。

后来在网上查询了解，华为手机可以在不开机的情况通过SD卡强制升级系统。好，说了这么多，终于到正题了，重装系统，步骤如下：

&lt;ol&gt;
  &lt;li&gt;准备一张 microSD 卡。&lt;/li&gt;
  &lt;li&gt;登录华为终端官网 consumer.huawei.com/cn，搜索“G750-T01”， 然后下载软件升级包。&lt;/li&gt;
  &lt;li&gt;在 microSD 卡根目录下创建一个【dload】文件夹。&lt;/li&gt;
  &lt;li&gt;将软件升级包中的“UPDATE.APP”拷贝到 microSD 卡【dload】文 件夹中。&lt;/li&gt;
  &lt;li&gt;将 microSD 卡插入手机&lt;/li&gt;
  &lt;li&gt;断开手机跟电脑或其它设备(如充电器)的连接，并关机。&lt;/li&gt;
  &lt;li&gt;同时按住音量上下键，然后按电源键。&lt;/li&gt;
  &lt;li&gt;开机画面出来之后，放开电源键，继续按住音量上下键，直到进入升级界面后再松开音量上下键。
整个升级过程大约需要 3 分钟。在升级过程中，请不要取出电池，建议您最好不要进行任何操作，静静等待。&lt;/li&gt;
&lt;/ol&gt;

等待几分钟后系统安装完成，手机重启，成功进入开机界面。大功告成！

</description>
        <pubDate>Sat, 06 Jan 2018 16:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/01/06/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/06/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/</guid>
        
        <category>技能</category>
        
        
        <category>刷机</category>
        
      </item>
    
  </channel>
</rss>
